// +build ignore

package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

const templateStr = `// Code generated by generate_handlers.go; DO NOT EDIT.

package etc_meisai

import (
	"net/http"
	"log"
)

// DynamicHandlerRegistry は動的にハンドラーを取得するためのレジストリ
// Swaggerから自動生成され、ハンドラーの存在を動的にチェックします
func (s *EtcMeisaiService) DynamicHandlerRegistry() map[string]func(http.ResponseWriter, *http.Request) {
	handlers := make(map[string]func(http.ResponseWriter, *http.Request))

	// Swaggerから取得したエンドポイントに対応するハンドラーを動的にチェック
{{range .Handlers}}
	// {{.Name}} - {{.Path}} [{{.Method}}]
	if h := HandlerChecker["{{.Name}}"]; h != nil {
		if handler := h(); handler != nil {
			handlers["{{.Name}}"] = handler
			log.Printf("✓ Handler found: {{.Name}}")
		}
	}
{{end}}

	return handlers
}

// GetHandlerForEndpoint はエンドポイントに対応するハンドラー名を返す
func (s *EtcMeisaiService) GetHandlerForEndpoint(path string, method string) string {
	mapping := map[string]string{
{{range .Handlers}}
		"{{.Method}}:{{.Path}}": "{{.Name}}",
{{end}}
	}

	key := method + ":" + path
	return mapping[key]
}
`

type Handler struct {
	Name   string
	Path   string
	Method string
}

func main() {
	// Swaggerファイルを取得
	resp, err := http.Get("https://raw.githubusercontent.com/yhonda-ohishi/etc_meisai/master/docs/swagger.yaml")
	if err != nil {
		log.Fatal("Failed to fetch swagger:", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatal("Failed to read swagger:", err)
	}

	// YAMLをパース
	var swagger map[string]interface{}
	if err := yaml.Unmarshal(body, &swagger); err != nil {
		log.Fatal("Failed to parse swagger:", err)
	}

	// パスからハンドラー情報を抽出
	var handlers []Handler
	if paths, ok := swagger["paths"].(map[string]interface{}); ok {
		for path, pathItem := range paths {
			if pathMap, ok := pathItem.(map[string]interface{}); ok {
				for method := range pathMap {
					upperMethod := strings.ToUpper(method)
					if upperMethod == "GET" || upperMethod == "POST" || upperMethod == "PUT" || upperMethod == "DELETE" {
						handlerName := pathToHandlerName(path, upperMethod)
						if handlerName != "" {
							handlers = append(handlers, Handler{
								Name:   handlerName,
								Path:   path,
								Method: upperMethod,
							})
						}
					}
				}
			}
		}
	}

	// テンプレートを実行
	tmpl, err := template.New("handlers").Parse(templateStr)
	if err != nil {
		log.Fatal(err)
	}

	file, err := os.Create("generated_registry.go")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	data := struct {
		Handlers []Handler
	}{
		Handlers: handlers,
	}

	if err := tmpl.Execute(file, data); err != nil {
		log.Fatal(err)
	}

	fmt.Println("Generated generated_registry.go")
}

// pathToHandlerName はパスとメソッドからハンドラー名を生成
func pathToHandlerName(path string, method string) string {
	// パスから期待されるハンドラー名を生成
	switch path {
	case "/health":
		return "HealthCheckHandler"
	case "/api/etc/accounts":
		return "GetAvailableAccountsHandler"
	case "/api/etc/download":
		return "DownloadETCDataHandler"
	case "/api/etc/download-single":
		return "DownloadSingleAccountHandler"
	case "/api/etc/download-async":
		return "DownloadAsyncHandler"
	case "/api/etc/download-status/{job_id}":
		return "GetDownloadStatusHandler"
	case "/api/etc/parse-csv":
		return "ParseCSVHandler"
	case "/api/etc/import":
		return "ImportDataHandler"
	case "/api/etc/meisai":
		if method == "GET" {
			return "GetMeisaiListHandler"
		}
		return "CreateMeisaiHandler"
	case "/api/etc/meisai/{id}":
		return "GetMeisaiByIDHandler"
	case "/api/etc/summary":
		return "GetSummaryHandler"
	default:
		return ""
	}
}