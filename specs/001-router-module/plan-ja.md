# 実装計画: ルーターモジュール

**ブランチ**: `001-router-module` | **日付**: 2025-09-12 | **仕様書**: [spec.md](./spec.md)
**入力**: 機能仕様書 `/specs/001-router-module/spec.md`

## 実行フロー (/plan コマンドスコープ)
```
1. 入力パスから機能仕様書を読み込み
   → 見つからない場合: ERROR "No feature spec at {path}"
2. 技術コンテキストを記入 (NEEDS CLARIFICATIONをスキャン)
   → コンテキストからプロジェクトタイプを検出 (web=frontend+backend, mobile=app+api)
   → プロジェクトタイプに基づいて構造決定を設定
3. 下記の構成チェックセクションを評価
   → 違反が存在する場合: 複雑性追跡に文書化
   → 正当化が不可能な場合: ERROR "Simplify approach first"
   → 進捗追跡を更新: 初期構成チェック
4. フェーズ0を実行 → research.md
   → NEEDS CLARIFICATIONが残っている場合: ERROR "Resolve unknowns"
5. フェーズ1を実行 → contracts, data-model.md, quickstart.md, エージェント固有のテンプレートファイル (例: Claude Code用の`CLAUDE.md`)
6. 構成チェックセクションを再評価
   → 新たな違反: 設計をリファクタリング、フェーズ1に戻る
   → 進捗追跡を更新: 設計後構成チェック
7. フェーズ2を計画 → タスク生成アプローチを記述 (tasks.mdは作成しない)
8. 停止 - /tasksコマンドの準備完了
```

**重要**: /planコマンドはステップ7で停止します。フェーズ2-4は他のコマンドで実行されます:
- フェーズ2: /tasksコマンドがtasks.mdを作成
- フェーズ3-4: 実装実行（手動またはツール経由）

## 概要
APIゲートウェイとして機能するルーターモジュールを作成し、複数のバックエンドサービスへのトラフィックを管理・分散する。Go言語でgorilla/muxを使用し、ミドルウェアパターンで横断的関心事を実装する。

## 技術コンテキスト
**言語/バージョン**: Go 1.23.0  
**主要依存関係**: gorilla/mux, golang.org/x/sync, prometheus/client_golang  
**ストレージ**: 設定ファイル（YAML/JSON）、メモリ内サービスレジストリ  
**テスティング**: go test, testify, httptest  
**ターゲットプラットフォーム**: Linux server, Docker, Kubernetes
**プロジェクトタイプ**: single - ルーターサービス単体  
**パフォーマンス目標**: 10,000 req/s、p99レイテンシ < 100ms  
**制約**: メモリ使用量 < 100MB、レスポンスタイム < 50ms  
**スケール/スコープ**: 10,000同時接続、5-10バックエンドサービス

## 構成チェック
*ゲート: フェーズ0研究前に合格する必要があります。フェーズ1設計後に再チェック。*

**シンプリシティ**:
- プロジェクト: 1 (ルーターのみ)
- フレームワークを直接使用? Yes (gorilla/muxを直接使用)
- 単一データモデル? Yes (ルーティング設定のみ)
- パターンを回避? Yes (不要なパターンは使用しない)

**アーキテクチャ**:
- すべての機能をライブラリとして? Yes
- ライブラリリスト:
  - router: HTTPルーティングとプロキシ機能
  - middleware: 認証、認可、ログ、メトリクス
  - config: 設定管理とホットリロード
  - health: ヘルスチェックとサーキットブレーカー
- ライブラリごとのCLI: 各ライブラリにCLIコマンドを提供
- ライブラリドキュメント: llms.txt形式で計画

**テスティング (交渉不可)**:
- RED-GREEN-Refactorサイクルを強制? Yes
- Gitコミットは実装前にテストを表示? Yes
- 順序: Contract→Integration→E2E→Unit厳密に従う? Yes
- 実際の依存関係を使用? Yes (実際のHTTPサーバー、モックなし)
- 統合テスト対象: 新しいライブラリ、契約変更、共有スキーマ? Yes
- 禁止: テスト前の実装、REDフェーズのスキップ

**可観測性**:
- 構造化ログを含む? Yes
- フロントエンドログ→バックエンド? N/A (バックエンドのみ)
- エラーコンテキスト十分? Yes

**バージョニング**:
- バージョン番号割り当て? Yes (1.0.0から開始)
- BUILDは変更ごとにインクリメント? Yes
- 破壊的変更の処理? Yes (並列テスト、移行計画)

## プロジェクト構造

### ドキュメント (この機能)
```
specs/001-router-module/
├── plan.md              # このファイル (/plan コマンド出力)
├── research.md          # フェーズ0出力 (/plan コマンド)
├── data-model.md        # フェーズ1出力 (/plan コマンド)
├── quickstart.md        # フェーズ1出力 (/plan コマンド)
├── contracts/           # フェーズ1出力 (/plan コマンド)
└── tasks.md             # フェーズ2出力 (/tasks コマンド - /planでは作成しない)
```

### ソースコード (リポジトリルート)
```
# オプション1: 単一プロジェクト (デフォルト)
src/
├── models/
│   └── config.go        # ルーティング設定モデル
├── services/
│   ├── router/          # ルーティングサービス
│   ├── proxy/           # プロキシサービス
│   └── health/          # ヘルスチェックサービス
├── cli/
│   └── router/          # ルーターCLIコマンド
└── lib/
    ├── middleware/      # ミドルウェアライブラリ
    └── config/          # 設定管理ライブラリ

tests/
├── contract/            # API契約テスト
├── integration/         # 統合テスト
└── unit/               # ユニットテスト
```

**構造決定**: オプション1（単一プロジェクト）を使用

## フェーズ0: アウトラインと研究

1. **技術コンテキストから未知数を抽出**:
   - gorilla/muxのベストプラクティス
   - Prometheusメトリクス統合パターン
   - サーキットブレーカー実装方法
   - ホットリロード設定の実装

2. **研究エージェントを生成・ディスパッチ**:
   ```
   Task: "Research gorilla/mux best practices for API gateway"
   Task: "Find circuit breaker patterns in Go"
   Task: "Research configuration hot-reload in Go applications"
   Task: "Find Prometheus integration patterns for Go HTTP servers"
   ```

3. **research.mdに調査結果を統合** (フォーマット):
   - 決定: [選択されたもの]
   - 根拠: [選択理由]
   - 検討された代替案: [評価された他の選択肢]

**出力**: すべてのNEEDS CLARIFICATIONが解決されたresearch.md

## フェーズ1: 設計と契約
*前提条件: research.md完了*

1. **機能仕様からエンティティを抽出** → `data-model.md`:
   - ルート設定エンティティ
   - サービスレジストリエンティティ
   - ヘルスステータスエンティティ

2. **機能要件からAPI契約を生成**:
   - ヘルスチェックエンドポイント
   - メトリクスエンドポイント
   - 管理エンドポイント（設定リロード）
   - OpenAPI仕様を`/contracts/`に出力

3. **契約から契約テストを生成**:
   - エンドポイントごとに1つのテストファイル
   - リクエスト/レスポンススキーマをアサート
   - テストは失敗する必要がある（まだ実装なし）

4. **ユーザーストーリーからテストシナリオを抽出**:
   - 各ストーリー→統合テストシナリオ
   - クイックスタートテスト = ストーリー検証ステップ

5. **エージェントファイルを段階的に更新** (O(1)操作):
   - AIアシスタント用の`/scripts/update-agent-context.sh claude`を実行
   - 現在のプランから新しい技術のみ追加
   - マーカー間の手動追加を保持
   - 最近の変更を更新（最後の3つを保持）
   - トークン効率のため150行未満に保つ
   - リポジトリルートに出力

**出力**: data-model.md, /contracts/*, 失敗するテスト, quickstart.md, CLAUDE.md

## フェーズ2: タスク計画アプローチ
*このセクションは/tasksコマンドが行うことを説明します - /plan中は実行しません*

**タスク生成戦略**:
- `/templates/tasks-template.md`をベースとして読み込み
- フェーズ1設計ドキュメント（契約、データモデル、クイックスタート）からタスクを生成
- 各契約→契約テストタスク [P]
- 各エンティティ→モデル作成タスク [P]
- 各ユーザーストーリー→統合テストタスク
- テストを合格させる実装タスク

**順序付け戦略**:
- TDD順序: 実装前のテスト
- 依存関係順序: モデル→サービス→UI
- 並列実行用に[P]をマーク（独立したファイル）

**推定出力**: tasks.mdに25-30の番号付き、順序付けされたタスク

**重要**: このフェーズは/tasksコマンドによって実行され、/planではありません

## フェーズ3+: 将来の実装
*これらのフェーズは/planコマンドのスコープ外です*

**フェーズ3**: タスク実行（/tasksコマンドがtasks.mdを作成）  
**フェーズ4**: 実装（憲法原則に従ってtasks.mdを実行）  
**フェーズ5**: 検証（テスト実行、quickstart.md実行、パフォーマンス検証）

## 複雑性追跡
*憲法チェックに正当化が必要な違反がある場合のみ記入*

| 違反 | 必要な理由 | より簡単な代替案が拒否された理由 |
|-----------|------------|-------------------------------------|
| なし | - | - |

## 進捗追跡
*このチェックリストは実行フロー中に更新されます*

**フェーズステータス**:
- [x] フェーズ0: 研究完了 (/plan コマンド)
- [x] フェーズ1: 設計完了 (/plan コマンド)
- [x] フェーズ2: タスク計画完了 (/plan コマンド - アプローチのみ記述)
- [ ] フェーズ3: タスク生成 (/tasks コマンド)
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲートステータス**:
- [x] 初期構成チェック: PASS
- [x] 設計後構成チェック: PASS
- [x] すべてのNEEDS CLARIFICATION解決
- [x] 複雑性逸脱文書化

---
*憲法v2.1.1に基づく - `/memory/constitution.md`参照*